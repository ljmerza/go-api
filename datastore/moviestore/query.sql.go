// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package moviestore

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgconn"
)

const createMovie = `-- name: CreateMovie :execresult
INSERT INTO movie (movie_id, extl_id, title, rated, released, run_time, director, writer,
                   create_app_id, create_user_id, create_timestamp, update_app_id, update_user_id, update_timestamp)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type CreateMovieParams struct {
	MovieID         uuid.UUID
	ExtlID          string
	Title           string
	Rated           sql.NullString
	Released        sql.NullTime
	RunTime         sql.NullInt32
	Director        sql.NullString
	Writer          sql.NullString
	CreateAppID     uuid.UUID
	CreateUserID    uuid.NullUUID
	CreateTimestamp time.Time
	UpdateAppID     uuid.UUID
	UpdateUserID    uuid.NullUUID
	UpdateTimestamp time.Time
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createMovie,
		arg.MovieID,
		arg.ExtlID,
		arg.Title,
		arg.Rated,
		arg.Released,
		arg.RunTime,
		arg.Director,
		arg.Writer,
		arg.CreateAppID,
		arg.CreateUserID,
		arg.CreateTimestamp,
		arg.UpdateAppID,
		arg.UpdateUserID,
		arg.UpdateTimestamp,
	)
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movie
WHERE movie_id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovie, movieID)
	return err
}

const findMovieByExternalID = `-- name: FindMovieByExternalID :one
SELECT m.movie_id, m.extl_id, m.title, m.rated, m.released, m.run_time, m.director, m.writer, m.create_app_id, m.create_user_id, m.create_timestamp, m.update_app_id, m.update_user_id, m.update_timestamp
FROM movie m
WHERE m.extl_id = $1
`

func (q *Queries) FindMovieByExternalID(ctx context.Context, extlID string) (Movie, error) {
	row := q.db.QueryRow(ctx, findMovieByExternalID, extlID)
	var i Movie
	err := row.Scan(
		&i.MovieID,
		&i.ExtlID,
		&i.Title,
		&i.Rated,
		&i.Released,
		&i.RunTime,
		&i.Director,
		&i.Writer,
		&i.CreateAppID,
		&i.CreateUserID,
		&i.CreateTimestamp,
		&i.UpdateAppID,
		&i.UpdateUserID,
		&i.UpdateTimestamp,
	)
	return i, err
}

const findMovieByExternalIDWithAudit = `-- name: FindMovieByExternalIDWithAudit :one
SELECT m.movie_id,
       m.extl_id,
       m.title,
       m.rated,
       m.released,
       m.run_time,
       m.director,
       m.writer,
       m.create_app_id,
       a.org_id           create_app_org_id,
       a.app_extl_id      create_app_extl_id,
       a.app_name         create_app_name,
       a.app_description  create_app_description,
       m.create_user_id,
       ou.username        create_username,
       ou.org_id          create_user_org_id,
       pp.first_name      create_user_first_name,
       pp.last_name       create_user_last_name,
       m.create_timestamp,
       m.update_app_id,
       a2.org_id          update_app_org_id,
       a2.app_extl_id     update_app_extl_id,
       a2.app_name        update_app_name,
       a2.app_description update_app_description,
       m.update_user_id,
       ou2.username       update_username,
       ou2.org_id         update_user_org_id,
       pp2.first_name     update_user_first_name,
       pp2.last_name      update_user_last_name,
       m.update_timestamp
FROM movie m
         INNER JOIN app a on a.app_id = m.create_app_id
         INNER JOIN app a2 on a2.app_id = m.update_app_id
         LEFT JOIN org_user ou on ou.user_id = m.create_user_id
         INNER JOIN person_profile pp on pp.person_profile_id = ou.person_profile_id
         LEFT JOIN org_user ou2 on ou2.user_id = m.update_user_id
         INNER JOIN person_profile pp2 on pp2.person_profile_id = ou2.person_profile_id
WHERE m.extl_id = $1
`

type FindMovieByExternalIDWithAuditRow struct {
	MovieID              uuid.UUID
	ExtlID               string
	Title                string
	Rated                sql.NullString
	Released             sql.NullTime
	RunTime              sql.NullInt32
	Director             sql.NullString
	Writer               sql.NullString
	CreateAppID          uuid.UUID
	CreateAppOrgID       uuid.UUID
	CreateAppExtlID      string
	CreateAppName        string
	CreateAppDescription string
	CreateUserID         uuid.NullUUID
	CreateUsername       string
	CreateUserOrgID      uuid.UUID
	CreateUserFirstName  string
	CreateUserLastName   string
	CreateTimestamp      time.Time
	UpdateAppID          uuid.UUID
	UpdateAppOrgID       uuid.UUID
	UpdateAppExtlID      string
	UpdateAppName        string
	UpdateAppDescription string
	UpdateUserID         uuid.NullUUID
	UpdateUsername       string
	UpdateUserOrgID      uuid.UUID
	UpdateUserFirstName  string
	UpdateUserLastName   string
	UpdateTimestamp      time.Time
}

func (q *Queries) FindMovieByExternalIDWithAudit(ctx context.Context, extlID string) (FindMovieByExternalIDWithAuditRow, error) {
	row := q.db.QueryRow(ctx, findMovieByExternalIDWithAudit, extlID)
	var i FindMovieByExternalIDWithAuditRow
	err := row.Scan(
		&i.MovieID,
		&i.ExtlID,
		&i.Title,
		&i.Rated,
		&i.Released,
		&i.RunTime,
		&i.Director,
		&i.Writer,
		&i.CreateAppID,
		&i.CreateAppOrgID,
		&i.CreateAppExtlID,
		&i.CreateAppName,
		&i.CreateAppDescription,
		&i.CreateUserID,
		&i.CreateUsername,
		&i.CreateUserOrgID,
		&i.CreateUserFirstName,
		&i.CreateUserLastName,
		&i.CreateTimestamp,
		&i.UpdateAppID,
		&i.UpdateAppOrgID,
		&i.UpdateAppExtlID,
		&i.UpdateAppName,
		&i.UpdateAppDescription,
		&i.UpdateUserID,
		&i.UpdateUsername,
		&i.UpdateUserOrgID,
		&i.UpdateUserFirstName,
		&i.UpdateUserLastName,
		&i.UpdateTimestamp,
	)
	return i, err
}

const findMovies = `-- name: FindMovies :many
SELECT m.movie_id,
       m.extl_id,
       m.title,
       m.rated,
       m.released,
       m.run_time,
       m.director,
       m.writer,
       m.create_app_id,
       a.org_id           create_app_org_id,
       a.app_extl_id      create_app_extl_id,
       a.app_name         create_app_name,
       a.app_description  create_app_description,
       m.create_user_id,
       ou.username        create_username,
       ou.org_id          create_user_org_id,
       pp.first_name      create_user_first_name,
       pp.last_name       create_user_last_name,
       m.create_timestamp,
       m.update_app_id,
       a2.org_id          update_app_org_id,
       a2.app_extl_id     update_app_extl_id,
       a2.app_name        update_app_name,
       a2.app_description update_app_description,
       m.update_user_id,
       ou2.username       update_username,
       ou2.org_id         update_user_org_id,
       pp2.first_name     update_user_first_name,
       pp2.last_name      update_user_last_name,
       m.update_timestamp
FROM movie m
         INNER JOIN app a on a.app_id = m.create_app_id
         INNER JOIN app a2 on a2.app_id = m.update_app_id
         LEFT JOIN org_user ou on ou.user_id = m.create_user_id
         INNER JOIN person_profile pp on pp.person_profile_id = ou.person_profile_id
         LEFT JOIN org_user ou2 on ou2.user_id = m.update_user_id
         INNER JOIN person_profile pp2 on pp2.person_profile_id = ou2.person_profile_id
`

type FindMoviesRow struct {
	MovieID              uuid.UUID
	ExtlID               string
	Title                string
	Rated                sql.NullString
	Released             sql.NullTime
	RunTime              sql.NullInt32
	Director             sql.NullString
	Writer               sql.NullString
	CreateAppID          uuid.UUID
	CreateAppOrgID       uuid.UUID
	CreateAppExtlID      string
	CreateAppName        string
	CreateAppDescription string
	CreateUserID         uuid.NullUUID
	CreateUsername       string
	CreateUserOrgID      uuid.UUID
	CreateUserFirstName  string
	CreateUserLastName   string
	CreateTimestamp      time.Time
	UpdateAppID          uuid.UUID
	UpdateAppOrgID       uuid.UUID
	UpdateAppExtlID      string
	UpdateAppName        string
	UpdateAppDescription string
	UpdateUserID         uuid.NullUUID
	UpdateUsername       string
	UpdateUserOrgID      uuid.UUID
	UpdateUserFirstName  string
	UpdateUserLastName   string
	UpdateTimestamp      time.Time
}

func (q *Queries) FindMovies(ctx context.Context) ([]FindMoviesRow, error) {
	rows, err := q.db.Query(ctx, findMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMoviesRow
	for rows.Next() {
		var i FindMoviesRow
		if err := rows.Scan(
			&i.MovieID,
			&i.ExtlID,
			&i.Title,
			&i.Rated,
			&i.Released,
			&i.RunTime,
			&i.Director,
			&i.Writer,
			&i.CreateAppID,
			&i.CreateAppOrgID,
			&i.CreateAppExtlID,
			&i.CreateAppName,
			&i.CreateAppDescription,
			&i.CreateUserID,
			&i.CreateUsername,
			&i.CreateUserOrgID,
			&i.CreateUserFirstName,
			&i.CreateUserLastName,
			&i.CreateTimestamp,
			&i.UpdateAppID,
			&i.UpdateAppOrgID,
			&i.UpdateAppExtlID,
			&i.UpdateAppName,
			&i.UpdateAppDescription,
			&i.UpdateUserID,
			&i.UpdateUsername,
			&i.UpdateUserOrgID,
			&i.UpdateUserFirstName,
			&i.UpdateUserLastName,
			&i.UpdateTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :exec
UPDATE movie
SET title            = $1,
    rated            = $2,
    released         = $3,
    run_time         = $4,
    director         = $5,
    writer           = $6,
    update_app_id    = $7,
    update_user_id   = $8,
    update_timestamp = $9
WHERE movie_id = $10
`

type UpdateMovieParams struct {
	Title           string
	Rated           sql.NullString
	Released        sql.NullTime
	RunTime         sql.NullInt32
	Director        sql.NullString
	Writer          sql.NullString
	UpdateAppID     uuid.UUID
	UpdateUserID    uuid.NullUUID
	UpdateTimestamp time.Time
	MovieID         uuid.UUID
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) error {
	_, err := q.db.Exec(ctx, updateMovie,
		arg.Title,
		arg.Rated,
		arg.Released,
		arg.RunTime,
		arg.Director,
		arg.Writer,
		arg.UpdateAppID,
		arg.UpdateUserID,
		arg.UpdateTimestamp,
		arg.MovieID,
	)
	return err
}
